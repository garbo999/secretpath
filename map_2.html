<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />  
  <style>
    #googleMap {
      width:100vw;
      height:100vh;}

    .gm-style img {
      -webkit-filter: grayscale(100%);
      -moz-filter: grayscale(100%);
      -ms-filter: grayscale(100%);
      -o-filter: grayscale(100%);
      filter: grayscale(100%);
      filter: url(grayscale.svg); /* Firefox 4+ */
      filter: gray; /* IE 6-9 */}
  </style>

<script
src="http://maps.googleapis.com/maps/api/js">
</script>

<script>
var TEST_MODE_PAR='testing';//if testing mode is 'true' then your location is fixed
var DEST_ID_PAR='destId';//destination parameter is where you want to play is it parnu or tallinn
var CITY_ID_PAR='cityId';//city id is where are YOU positioned!
var FIND_DESTIN='indexMode';// values random_index, min_index, destId
var marker;
/*var test_mode = false;
var test_mode = true;
*/
var my_lat, my_long;

// destination array
// position_array[0][0] --> position 1 destination 0 (P'rnu latitude
// position_array[0][1] --> position 1 destination 1 Tallinn  longitude etc.
var position_array;
// long, lat, name description, picture, landing QRI text
var parnu_pos = 
  [
    [58.38432, 24.49296, 'Vallikaar', 'picture link', 'Palju õnne leidsite Vallikaare!'], // vallikaar
    [58.37641, 24.47798, 'Spit', 'picture link', 'Palju õnne leidsite Pärnu sadama!'], // spit
    [58.38053, 24.49229, 'Amanda Villa', 'picture link', 'Palju õnne leidsite Amanda Villa!'], // amanda villa
    [58.37859, 24.50497, 'Villa Ene', 'picture link', 'Palju õnne leidsite Villa Ene!'], // villa ene
    [58.38267, 24.48776, 'Spa tervis', 'picture link', 'Palju õnne leidsite Spa tervise keskuse!'], // spa tervis
  ];
var tallinn_pos = [
  [59.4371997, 24.7452441, 'Raekoja plats', 'picture link', 'Palju õnne olete jõudnud Raekoja platsi!'], // Raekoja plats
  [59.43727476, 24.74703938, 'Meistrite Hoov', 'picture link', 'Palju õnne olete jõudnud Meistrite hoovi! See vaikne vanalinna sisehoov on killuke sajanditetagusest Tallinnast, mil hinnati käsitöömeistrite hingega tehtud töid. Säilinud on keskaegset arhitektuuri ja õdusat atmosfääri. Avatud on erinevad kunsti- ja käsitöökojad, külalistetoad majutuseks ning kuulus kohvik Chocolaterie. '], // Meistrite Hoov
  [59.43832764, 24.74351496, 'Nukuteater ja muuseum', 'picture link', 'Palju õnne olete leidnud Nukuteatri ja muuseumi! Vähem on rohkem! Inimesega võrreldes saadavad väikesed nukud korda suuri tegusid. Nukuteatris tegeletakse iga päev nähtamatu nähtavaks muutmisega siin saavad kuju kurbus ja armastus ning ellu ärkavad lusikas ja võileib. Kui teil teatriisu peale tuleb, tulge külla NUKU muuseumisse! NUKU muuseumis saab näha nukuteatrit, teha teatrinukke ja proovida kõike, mida teatris ikka tehakse. Nukuteatrimaailm on täis huvitavaid lugusid, toredaid tegevusi ja siin elab sadu teatrinukke.'], // Eesti Riiklik Nukuteater
  [59.4357172, 24.7435686, 'Harju Tänava Uisuplats', 'picture link', 'Palju õnne olete leidnud Harju Tänava Uisuplatsi! Liuglemine Harju tänava uisuplastil on parim võimalus kogeda romantilist talvemeeleolu ning koos perega lõbusalt aega veeta. Nii uisutajad kui kõik teised külastajad on teretulnud uisuplatsi kõrval asuvasse kohvikusse ennast kuuma joogiga soojendama. Kaunilt valgustatud vanalinn sinu ümber jätab sellest päevast kustumatu mälestuse. '], // Harju Tänava Uisuplats
  [59.43718202, 24.74771529, 'Pierre Chocolaterie', 'picture link', 'Palju õnne olete leidnud Pierre šhokolaadi kohviku! Linna üks unustamatuim kohvik asub otse Raekoja platsi kõrval. Madalate võlvlagedega hubaseid ruume täidavad vanaaegne mööbel, küünlavalgus ja eesti muusika. Siin võid proovida erinevaid tee- ja kohvisorte, nautida eestimaisest toorainest tehtud kooke või proovida mõnd neist käsitsi valmistatud suussulavatest trühvlitest, mille järgi kohvik endale nime on saanud.'] // Pierre Chocolaterie
];

var city_array = [
  [58.38502, 24.48900], // parnu college
  [59.4371997, 24.7452441] // tallinn raekoja plats
];

function getParameterByName(name) {
    name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
    var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
        results = regex.exec(location.search);
    return results === null ? "" : decodeURIComponent(results[1].replace(/\+/g, " "));
}

var destId = getParameterByName(DEST_ID_PAR);
// if not defined then Parnu
if(destId === undefined) {
  destId = 0;
  position_array = parnu_pos;
  // if 1 then tallinn
}else if (destId==1){
   position_array = tallinn_pos; 
}else{
  // was still parnu
  position_array = parnu_pos;
}  
var cityId = parseInt(getParameterByName(CITY_ID_PAR));
if(city_array[cityId] === undefined) {
  cityId = 0; // Parnu by default
}else if(cityId==1){
  cityId = 1;
}  
console.log(CITY_ID_PAR,'=', cityId);

var testMode = getParameterByName(TEST_MODE_PAR);
if(testMode != 'true' && testMode != 'false') {
  testMode = 'false';
}

var indexMode = getParameterByName(FIND_DESTIN);
if(indexMode != 'random_index' && indexMode != 'min_index' && indexMode != 'destId') {
  indexMode = 'min_index';
}


if (typeof(Number.prototype.toRad) === "undefined") {
  Number.prototype.toRad = function() {
    return this * Math.PI / 180;
  }
}
if (typeof(Number.prototype.toDeg) === "undefined") {
  Number.prototype.toDeg = function() {
    return this * 180 / Math.PI;
  }
}

/**
 * Returns a random integer between min (inclusive) and max (inclusive)
 * Using Math.round() will give you a non-uniform distribution!
 */
function getRandomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}
 
function getDistanceFromLatLonInKm(lat1,lon1,lat2,lon2) {
  var R = 6371; // Radius of the earth in km
  var dLat = deg2rad(lat2-lat1);  // deg2rad below
  var dLon = deg2rad(lon2-lon1); 
  var a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * 
    Math.sin(dLon/2) * Math.sin(dLon/2)
    ; 
  var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); 
  var d = R * c; // Distance in km
  return d;
}

function deg2rad(deg) {
  return deg * (Math.PI/180)
}

var options = {
  enableHighAccuracy: false,
  timeout: 1000,
  maximumAge: 0
};

function getLocation() {
  if (navigator.geolocation) {
      navigator.geolocation.watchPosition(initialize, errorCallback, options);
  } else {
      x.innerHTML = "Geolocation is not supported by this browser.";
  }
}

function errorCallback(error) {
    switch(error.code) {
        case error.PERMISSION_DENIED:
            x.innerHTML = "User denied the request for Geolocation."
            break;
        case error.POSITION_UNAVAILABLE:
            x.innerHTML = "Location information is unavailable."
            break;
        case error.TIMEOUT:
            x.innerHTML = "The request to get user location timed out."
            break;
        case error.UNKNOWN_ERROR:
            x.innerHTML = "An unknown error occurred."
            break;
    }
}

function initialize(position) {
  var x = document.getElementById("demo");
  // if testing mode then show your location parameters in html
  if (testMode == "true") {
    // x.innerHTML = "Latitude: " + position.coords.latitude + "<br>Longitude: " + position.coords.longitude; 
  }
  // if testing mode is true then take your location by city ID
  if (testMode == "true") {
    my_lat = city_array[cityId][0];
    my_long = city_array[cityId][1];
  } else {
    // take your location automatically
    my_lat = position.coords.latitude;
    my_long = position.coords.longitude;
  }


  var distance_array = new Array();
  var min_index;
  for (i = 0; i < position_array.length; i++) {
      distance_array.push(getDistanceFromLatLonInKm(my_lat,my_long,position_array[i][0],position_array[i][1]));
  }

  var min_index = distance_array.indexOf(Math.min.apply(Math, distance_array));
  var random_index = getRandomInt(0, distance_array.length-1);

  // desired_index is a parameter set in the URL:
  //    min_index --> (choose closest destination)
  //    random_index --> choose random destination
  //    destId --> choose destination id from parameters in URL string
  var desired_index; // three choices: min_index, random_index or destId
  
  if (indexMode == 'random_index') {
    desired_index = random_index;
  } else if (indexMode == 'min_index') {
    desired_index = min_index;
  } else if (indexMode == 'destId') {
    desired_index = destId;
  } else {
    desired_index = min_index;
  } 

  // DEBUGGING
  console.log(distance_array);
  console.log('min_index=', min_index);
  console.log('random_index=', random_index);
  console.log('destId=', destId);
  console.log('testMode=', testMode);
  console.log('indexMode=', indexMode);
  console.log('my_lat=', my_lat);
  console.log('my_long=', my_long);
  // DEBUGGING

  var myCenter=new google.maps.LatLng(my_lat, my_long);
  var myPos2=new google.maps.LatLng(position_array[desired_index][0], position_array[desired_index][1]); // for testing
  //var myPos2=new google.maps.LatLng(position_array[min_index][0], position_array[min_index][1]);

  var mapProp = {
    center:myCenter,
    zoom:15,
    mapTypeId:google.maps.MapTypeId.ROADMAP,
    zoomControl: false
  };

  var map=new google.maps.Map(document.getElementById("googleMap"),mapProp);
  map.setOptions({draggable: false, zoomControl: false, scrollwheel: false, disableDoubleClickZoom: true});
  // need to combine setOptions with mapProp

/*  var marker=new google.maps.Marker({
    position:myCenter,
    icon:'pinkball.png'
    //icon:'safe_image.png'
  });
*/  

  // destination position
  var marker1=new google.maps.Marker({
    position:myPos2,
  });

  //marker.setMap(map);
  marker1.setMap(map);

  var bounds = new google.maps.LatLngBounds();
  bounds.extend(myCenter);
  bounds.extend(myPos2);
  map.fitBounds(bounds);

  var infowindow = new google.maps.InfoWindow({
    content: position_array[desired_index][2]
    });

  infowindow.open(map,marker1);


  lat1 = my_lat;
  lon1 = my_long;
  lat2 = position_array[desired_index][0];
  lon2 = position_array[desired_index][1];
  //lat2 = position_array[min_index][0];
  //lon2 = position_array[min_index][1];

  var dLat = (lat2-lat1).toRad();
  var dLon = (lon2-lon1).toRad();
  var lat1 = lat1.toRad();
  var lat2 = lat2.toRad();

  var y = Math.sin(dLon) * Math.cos(lat2);
  var x = Math.cos(lat1)*Math.sin(lat2) -
          Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
  var brng = Math.atan2(y, x).toDeg();

  // DEBUGGING
  console.log('brng=' +brng);

  placeMarker(map.getCenter(), brng);

  //function
  function placeMarker(location, rotation) {
    marker = new google.maps.Marker({
      position: location,
      icon: {
        path: google.maps.SymbolPath.FORWARD_CLOSED_ARROW,
        scale: 7,
        //fillColor:
        //fillOpacity:
        //https://developers.google.com/maps/documentation/javascript/symbols
        rotation: rotation
      },
      draggable: false,
      map: map
    });
  }

  // this could be used to display an infowindow for the user location
/*  var infowindow = new google.maps.InfoWindow({
    content: "some text here"
    });

  infowindow.open(map,marker);
*/


}

google.maps.event.addDomListener(window, 'load', getLocation);
</script>
</head>

<body>
  <p id="demo"></p>
  <div id="googleMap"></div>
</body>
</html>
